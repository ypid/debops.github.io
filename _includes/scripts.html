<script>
(function() {

  function getJSON(url, successHandler, errorHandler) {
    var xhr = new XMLHttpRequest();
    xhr.open('get', url, true);
    xhr.responseType = 'json';
    xhr.onload = function() {
      var status = xhr.status;
      if (status == 200) {
        successHandler && successHandler(xhr.response);
      } else {
        errorHandler && errorHandler(status);
      }
    };
    xhr.send();
  };

  function github_repo(metadata, role_full_name) {
    var a = document.createElement('a');
    a.setAttribute('class', 'item_attr');
    a.setAttribute('href', metadata.vcs_url);
    a.setAttribute('title', 'View it on GitHub');
    a.innerHTML = role_full_name ;
    return a;
  }

  function travis_badge(metadata, role_full_name) {
    var img = document.createElement('img');
    img.setAttribute('src', metadata.ci_badge_url);
    img.setAttribute('alt', 'Build status');

    var a = document.createElement('a');
    a.setAttribute('href', metadata.ci_url);
    a.setAttribute('class', 'item_attr');
    a.setAttribute('href', metadata.ci_url);
    a.appendChild(img)
    return a;
  }

  function testsuite_link(metadata, role_full_name) {
    var a = document.createElement('a');
    a.setAttribute('class', 'item_attr');
    a.setAttribute('href', metadata.test_suite_url);
    a.innerHTML = '[view tests]';
    return a;
  }

  function role_format_version(metadata, role_full_name) {
    var span = document.createElement('span');
    span.setAttribute('class', 'item_attr');
    span.innerHTML = '[Standards: v' + metadata.role_format_version + ']';
    return span;
  }

  function role_version(metadata, role_full_name) {
    if (metadata.hasOwnProperty('changelog_url')) {
      var elem = document.createElement('a');
      elem.setAttribute('href', metadata.changelog_url);
    } else {
      var elem = document.createElement('span');
    }
    elem.setAttribute('class', 'item_attr');

    var version = 'unknown';
    if (metadata.hasOwnProperty('version')) {
      version = 'v' + metadata.version;
    }
    if (version === 'unknown') {
      elem.setAttribute('title', 'Unknown because currently not provided by the DebOps API (reason: Standards Version too old).');
    }

    elem.innerHTML = '[Release: ' + version + ']';
    return elem;
  }

  function min_ansible_version(metadata, role_full_name) {
    var span = document.createElement('span');
    span.setAttribute('class', 'item_attr');
    span.innerHTML = '[Min. Ansible : v' + metadata.min_ansible_version + ']';
    return span;
  }

  function build_status() {
    var tbody = document.getElementById('status').getElementsByTagName('tbody')[0];
    var role_count = 0;

    getJSON('https://api.debops.org/v0/roles/debops.json', function(data) {
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          role_count++;

          var row = tbody.insertRow(tbody.rows.length);

          row.insertCell(0).appendChild(github_repo(data[key], key));
          row.insertCell(1).appendChild(travis_badge(data[key], key));
          row.insertCell(2).appendChild(testsuite_link(data[key], key));
          row.insertCell(3).appendChild(role_version(data[key], key));
          row.insertCell(4).appendChild(role_format_version(data[key], key));

          var tds = document.getElementsByTagName('td');
          tds[1].style.width = '4rem';
          tds[2].style.width = '4.2rem';
          tds[3].style.width = '7rem';
          tds[4].style.width = '7rem';
        }
      }
      document.getElementById('role_count').innerHTML = role_count;
    });
  }

  function update_role_count() {
    var xhr = new XMLHttpRequest();
    xhr.open('get', 'https://api.debops.org/v0/roles/count:debops', true);
    xhr.onload = function() {
      var status = xhr.status;
      if (status == 200) {
        document.getElementById('role_count').innerHTML = xhr.response;
      }
    };
    xhr.send();
  }

  if (document.getElementById('status')) {
    build_status();
  } else if (document.getElementById('role_count')) {
    update_role_count();
  }

})();
</script>
